---
import { Icon } from "astro-icon/components";
import { profileConfig } from "../../config";
import { url } from "../../utils/url-utils";
import ImageWrapper from "../misc/ImageWrapper.astro";

const config = profileConfig;
---

<div class="card-base p-3 profile-card-container">
    <a aria-label="Go to About Page" href={url('/about/')}
       class="group block relative mx-auto mt-1 lg:mx-0 lg:mt-0 mb-3
       max-w-[12rem] lg:max-w-none overflow-hidden rounded-xl active:scale-95 profile-link-area">
        
        <div id="profile-mask" class="absolute inset-0 z-50 flex items-center justify-center transition-all duration-500 opacity-0 pointer-events-none">
            <div class="absolute inset-0 bg-black/30 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <Icon name="fa6-regular:address-card"
                  class="relative z-10 transition opacity-0 scale-90 group-hover:scale-100 group-hover:opacity-100 text-white text-5xl drop-shadow-lg">
            </Icon>
        </div>

        <canvas id="split-canvas" class="absolute inset-0 z-40 w-full h-full cursor-pointer transition-opacity duration-500"></canvas>

        <div id="source-image-container" class="w-full h-full opacity-0 pointer-events-none transition-opacity duration-500">
            <ImageWrapper src={config.avatar || ""} alt="Profile Image of the Author" class="mx-auto lg:w-full h-full lg:mt-0 object-cover"></ImageWrapper>
        </div>
    </a>

    <div class="px-2">
        <div class="font-bold text-xl text-center mb-1 dark:text-neutral-50 transition">{config.name}</div>
        <div class="h-1 w-5 bg-[var(--primary)] mx-auto rounded-full mb-2 transition"></div>
        <div class="text-center text-neutral-400 mb-2.5 transition" set:html={config.bio}></div>
        <div class="flex gap-2 justify-center mb-1">
            {config.links.length > 1 && config.links.map(item =>
                    <a rel="me" aria-label={item.name} href={item.url} target="_blank" class="btn-regular rounded-lg h-10 w-10 active:scale-90">
                        <Icon name={item.icon} class="text-[1.5rem]"></Icon>
                    </a>
            )}
            {config.links.length == 1 && <a rel="me" aria-label={config.links[0].name} href={config.links[0].url} target="_blank"
                                            class="btn-regular rounded-lg h-10 gap-2 px-3 font-bold active:scale-95">
                <Icon name={config.links[0].icon} class="text-[1.5rem]"></Icon>
                {config.links[0].name}
            </a>}
        </div>
    </div>
</div>

<script>
    const MIN_RESOLUTION = 12;
    const AUTO_COMPLETE_RATIO = 0.7;
    const BLUR_FACTOR = 10;

    class Particle {
        x: number;
        y: number;
        w: number;
        h: number;
        children: Particle[];
        isLeaf: boolean;

        constructor(x: number, y: number, w: number, h: number) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.children = [];
            this.isLeaf = true;
        }

        draw(ctx: CanvasRenderingContext2D, sourceImg: CanvasImageSource, scale: number, imgOffsetX: number, imgOffsetY: number) {
            if (!this.isLeaf) {
                for (const child of this.children) {
                    child.draw(ctx, sourceImg, scale, imgOffsetX, imgOffsetY);
                }
                return;
            }

            const sx = (this.x - imgOffsetX) / scale;
            const sy = (this.y - imgOffsetY) / scale;
            const sw = this.w / scale;
            const sh = this.h / scale;

            if (this.w <= MIN_RESOLUTION) {
                ctx.drawImage(sourceImg, sx, sy, sw, sh, this.x, this.y, this.w + 0.5, this.h + 0.5);
            } else {
                ctx.save();
                ctx.beginPath();
                const radius = this.w / 2;
                const cx = this.x + radius;
                const cy = this.y + radius;
                ctx.arc(cx, cy, radius * 1.02, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();

                const blurAmount = Math.max(2, this.w / BLUR_FACTOR);
                ctx.filter = `blur(${blurAmount}px)`;

                ctx.drawImage(sourceImg, sx, sy, sw, sh, this.x - 1, this.y - 1, this.w + 2, this.h + 2);
                ctx.restore();
            }
        }

        split() {
            if (!this.isLeaf) return;
            const halfW = this.w / 2;
            const halfH = this.h / 2;
            this.children.push(
                new Particle(this.x, this.y, halfW, halfH),
                new Particle(this.x + halfW, this.y, halfW, halfH),
                new Particle(this.x, this.y + halfH, halfW, halfH),
                new Particle(this.x + halfW, this.y + halfH, halfW, halfH)
            );
            this.isLeaf = false;
        }

        checkMouse(mouseX: number, mouseY: number) {
            if (mouseX < this.x || mouseX > this.x + this.w ||
                mouseY < this.y || mouseY > this.y + this.h) {
                return;
            }

            if (this.isLeaf) {
                if (this.w > MIN_RESOLUTION) { 
                    this.split();
                    this.children.forEach(c => c.checkMouse(mouseX, mouseY));
                }
            } else {
                for (const child of this.children) {
                    child.checkMouse(mouseX, mouseY);
                }
            }
        }

        getRestoredArea(): number {
            if (this.isLeaf) {
                if (this.w <= MIN_RESOLUTION) {
                    return this.w * this.h;
                }
                return 0;
            } else {
                let sum = 0;
                for (const child of this.children) {
                    sum += child.getRestoredArea();
                }
                return sum;
            }
        }
    }

    function initSplitEffect() {
        const linkArea = document.querySelector('.profile-link-area');
        const canvas = document.getElementById('split-canvas')!;
        const imgContainer = document.getElementById('source-image-container')!;
        const img = imgContainer.querySelector('img')!;
        const mask = document.getElementById('profile-mask')!;

        if (!canvas || !img || !linkArea || !mask) return;

        const ctx = (canvas as HTMLCanvasElement).getContext('2d');
        if (!ctx) return;

        let rootParticle: Particle | null = null;
        let animationFrameId: number;
        let drawParams = { scale: 1, x: 0, y: 0 };
        let totalArea = 0;
        let isComplete = false;

        const start = () => {
            const rect = linkArea.getBoundingClientRect();
            const cvs = canvas as HTMLCanvasElement;
            cvs.width = Math.floor(rect.width);
            cvs.height = Math.floor(rect.height);
            totalArea = cvs.width * cvs.height;
            isComplete = false;

            cvs.style.opacity = '1';
            cvs.style.pointerEvents = 'auto';
            imgContainer.classList.add('opacity-0');
            mask.classList.add('opacity-0', 'pointer-events-none');

            const scale = Math.max(cvs.width / img.naturalWidth, cvs.height / img.naturalHeight);
            const x = (cvs.width / 2) - (img.naturalWidth / 2) * scale;
            const y = (cvs.height / 2) - (img.naturalHeight / 2) * scale;
            drawParams = { scale, x, y };

            rootParticle = new Particle(0, 0, cvs.width, cvs.height);
            animate();
        };

        const animate = () => {
            if (!ctx || !rootParticle) return;
            if (isComplete) return;

            const cvs = canvas as HTMLCanvasElement;
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            rootParticle.draw(ctx, img, drawParams.scale, drawParams.x, drawParams.y);
            
            const restoredArea = rootParticle.getRestoredArea();
            if (restoredArea / totalArea >= AUTO_COMPLETE_RATIO) {
                finishEffect();
            } else {
                animationFrameId = requestAnimationFrame(animate);
            }
        };

        const finishEffect = () => {
            isComplete = true;
            cancelAnimationFrame(animationFrameId);

            const cvs = canvas as HTMLCanvasElement;
            cvs.style.opacity = '0';
            cvs.style.pointerEvents = 'none';

            imgContainer.classList.remove('opacity-0');
            mask.classList.remove('opacity-0', 'pointer-events-none');
        };

        linkArea.addEventListener('mousemove', (e) => {
            if (isComplete) return;

            const event = e as MouseEvent;
            const cvs = canvas as HTMLCanvasElement;
            const rect = cvs.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            if (rootParticle) {
                rootParticle.checkMouse(mouseX, mouseY);
            }
        });

        if (img.complete) {
            start();
        } else {
            img.onload = start;
        }
        
        window.addEventListener('resize', () => {
             cancelAnimationFrame(animationFrameId);
             setTimeout(start, 200);
        });
    }

    document.addEventListener('astro:page-load', initSplitEffect);
    initSplitEffect();
</script>